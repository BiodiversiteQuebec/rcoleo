---
title: "Importer les données depuis le fichier Excel du ministère"
author: "Steve Vissault"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```r

#### POST fonctions
# Function to upload on db




#################################################################

library(readxl)
library(dplyr)
library(stringr)
library(tibble)
library(tidyr)
library(rgdal)
library(geojsonio)

# importer la table des valeurs de reference
ref_values <- read_excel("./extdata/CompilationDonnées_2016-2018.xlsx",sheet=1)

# Séléctionner les feuilles qui seront injectées dans la BD
sheets <- c("Végétation","Sol","Carabes_Installation","Inv. acoustique","papillon","odonate")

# Chaque feuille sera un niveau de la liste `coleo_ls`
coleo_ls <- list()

# Boucle sur les feuilles
for(i in 1:length(sheets)){
  ## premiere lecture de la page
  nms <- names(read_excel("./extdata/CompilationDonnées_2016-2018.xlsx",sheet=sheets[i]))

  ## Gerer les dates (eviter la conversion automatique)
  ct <- ifelse(grepl("^Date", nms,ignore.case = TRUE), "date", "guess")

  ## deuxieme lecture de la page
  coleo_ls[[i]] <- read_excel("./extdata/CompilationDonnées_2016-2018.xlsx",sheet=sheets[i],col_types = ct,trim_ws=TRUE)

  ## replacer les espaces par des barres de soulignement dans les noms de colonnes
  names(coleo_ls[[i]]) <- str_replace_all(names(coleo_ls[[i]])," ", "_")
  ## Ajouter le nom de la feuille au tableau de données
  coleo_ls[[i]]$sheet <- sheets[i]
}

# Nomme les niveaux de la liste
names(coleo_ls) <- sheets

################
#### SITES #####
################

# Liste des champs pour les sites
names_site<-c("Nom_de_la_cellule","No_de_référence_de_la_cellule","No_de_référence_du_site","No_borne_forestière","Type_de_milieu","Latitude","Longitude","WP")

# Liste des sites
sites <- list()

# Obtenir les colonnes detenant l'information sur les sites a travers toutes les campagnes
for(i in 1:length(coleo_ls)){
  colsite <- names_site[which(names_site %in% names(coleo_ls[[i]]))]
  sites[[i]] <- coleo_ls[[i]][,colsite]
}

## Fusionner site ensemble et faire un unique pour controller les éventuelles doublons
sites <- as.tibble(do.call(plyr::rbind.fill,sites))

#######################
## Corrections des erreurs
#######################

# replacer les IDs de site avec des barres de soulignement lorque c'est des barres du milieu
sites$No_de_référence_du_site <- str_replace_all(sites$No_de_référence_du_site,"-","_")
# Même chose pour les No_borne_forestière
sites$No_borne_forestière <- str_replace_all(sites$No_borne_forestière,"-","_")
# Controle sur le numéro de bornes (si No_de_référence_du_site == No_borne_forestière alors fixe à NA)
sites[which(sites$No_de_référence_du_site == sites$No_borne_forestière),"No_borne_forestière"] <- NA
# Éliminer spécifique erreur de saisie
sites[which(sites$No_borne_forestière=="141_108_H01"),] <- NA # Inconsistence avec le No_de_référence_du_site
# Éliminer les informations redondantes
sites <- unique(sites)
# Drop sites qui n'ont pas de numéro de site
#sites <- sites[!is.na(sites$No_de_référence_du_site),] # À commenter si l'on veut faire l'analyse des erreurs
# Retirer les lignes Vides
sites <- sites[which(rowSums(is.na(sites))!=ncol(sites)),]


## Regarder les sites dupliquer
sites$WP <- as.numeric(sites$WP)
sites <- sites[order(sites$WP),]
write.csv(sites,file="./extdata/csv/sites.csv",row.names=F)

###########################
##### Injection Cellules ##
###########################

# Authentification
bearer <- readRDS(".httr-oauth")

# Match sur les champs de l'API
cells <- as.data.frame(unique(sites[,c("Nom_de_la_cellule","No_de_référence_de_la_cellule")]))
names(cells) <- c("name","cell_code")

# Ajouter les polygones de cellules
shp_cells <- readOGR(dsn="./extdata/shp/",layer="Qc15_present")

# Reprojection vers Quebec Lambert Conic
shp_cells <- sp::spTransform(shp_cells,CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs;"))

# Loop par dessus les noms de cellules pour aller chercher son polygon.
cells_ls <- list()

for(i in 1:nlevels(shp_cells$IJ)){

  cell_code <- levels(shp_cells$IJ)[i]
  shp <- shp_cells[shp_cells$IJ == cell_code ,]

  cells_ls[[i]] <- list()
  cells_ls[[i]]$cell_code <- cell_code
  cells_ls[[i]]$name <- ifelse(cell_code %in% cells$cell_code,cells[which(cells$cell_code == cell_code),"name"],NA)

  shp_sp <- as(shp, "SpatialPolygons")
  cells_ls[[i]]$shp <- geojson_list(shp)$features[[1]]$geometry

  # Add CRS fields
  cells_ls[[i]]$shp$crs <- list(type="name",properties=list(name="EPSG:4326"))

}

# Transform les donnees en JSON
# resp_cells <- postColeo(endpoint="/cells",lt=cells_ls)

# Envoyer seulement les donnees avec un nom de cellule
resp_cells <- postCells(lt=cells_ls[which(!is.na(sapply(cells_ls,function(x) return(x$name))))])

cells_ls[which(!is.na(sapply(cells_ls,function(x) return(x$name))))][[1]]

###########################
#### Injection des sites ##
###########################

sites <- select(sites,No_de_référence_de_la_cellule,No_de_référence_du_site,Type_de_milieu,No_borne_forestière,Latitude,Longitude)
names(sites) <- c("cell_code","site_code","type","monit_prg_station_id","lat","lon")

sites_ls <- apply(sites,1,as.list)

# Creer geom points
loc <- apply(sites,1, function(x){
  if(!any(is.na(x["lat"]),is.na(x["lon"]))){
  return(geojson_list(as.numeric(c(x["lat"],x["lon"])))$features[[1]]$geometry)
} else {
  return(NA)
}})

# Fusionner les deux listes (locations + sites)
for(i in 1:length(sites_ls)){
  sites_ls[[i]]$loc <- loc[i][[1]]
  if(is.list(sites_ls[[i]]$loc)){
    sites_ls[[i]]$loc$crs <- list(type="name",properties=list(name="EPSG:4326"))
  }
}

resp_sites <- postSites(lt=sites_ls)



###################
#### CAMPAGNES ####
###################

# Liste des champs pour les campagnes
names_campaign <- c("No_de_référence_du_site","sheet","Date_inventaire_estival","Date_inventaire_printanier","Date_inventaire","Date_d'installation","Date_de_retrait","Date_d'inventaire","Nom_observateur_1","Nom_observateur_2")

# Liste des campagnes
campagnes <- list()

# Obtenir les colonnes detenant l'information sur les campagnes (techniciens)
for(i in 1:length(coleo_ls)){
  colcamp <- names_campaign[which(names_campaign %in% names(coleo_ls[[i]]))]
  campagnes[[i]] <- coleo_ls[[i]][,colcamp]
}

## Fusionner site ensemble et faire un unique pour controller les éventuelles doublons
campagnes <- as.tibble(do.call(plyr::rbind.fill,campagnes))

## Obtenir les entrées uniques
campagnes <- unique(campagnes)

#######################
## Controle des erreurs
#######################

# replacer les IDs de site avec des barres de soulignement lorque c'est des barres du milieu
campagnes$No_de_référence_du_site <- str_replace_all(campagnes$No_de_référence_du_site,"-","_")

###############################################
## Formattage du fichier CSV pour campagnes
###############################################

# renommer et formatter la colonne "sheet" en minuscule
campagnes$sheet <- tolower(campagnes$sheet)
campagnes <- rename(campagnes, type = sheet)
# fusionner les colonnes pour obtenir une date d'ouverture d'inventaire et une date de fermeture
campagnes <- gather(campagnes,"keys","Date",-No_de_référence_du_site,-type,-Nom_observateur_1,-Nom_observateur_2,na.rm=TRUE)
# Creer les colonnes Date d'ouverture et Date de fermeture
cols_date_ouverture <- c("Date_inventaire_printanier","Date_d'installation")
cols_date_fermeture <- c("Date_de_retrait","Date_inventaire_estival")
cols_date_deux <- c("Date_d'inventaire","Date_inventaire")

campagnes[which(campagnes$keys %in% cols_date_ouverture),"keys"] <-  "Date_ouverture"
campagnes[which(campagnes$keys %in% cols_date_fermeture),"keys"] <-  "Date_fermeture"
campagnes[which(campagnes$keys %in% cols_date_deux),"keys"] <-  "Ouverture_fermeture"

# Retourner au format long
campagnes <- campagnes %>% unique() %>% group_by(No_de_référence_du_site,type,keys,Nom_observateur_1,Nom_observateur_2) %>% mutate(no_mesure = row_number())
campagnes$no_mesure <- as.numeric(campagnes$no_mesure)
campagnes$Date <- as.character(campagnes$Date)
campagnes <- reshape2::dcast(No_de_référence_du_site+type+no_mesure+Nom_observateur_1+Nom_observateur_2 ~ keys, data=campagnes,value.var="Date")

# remplacer les dates d'ouverture et de fermeture quand l'inventaire se tient dans une meme journee
campagnes[which(!is.na(campagnes$Ouverture_fermeture)),"Date_ouverture"] <- campagnes[which(!is.na(campagnes$Ouverture_fermeture)),"Ouverture_fermeture"]

campagnes[which(!is.na(campagnes$Ouverture_fermeture)),"Date_fermeture"] <- campagnes[which(!is.na(campagnes$Ouverture_fermeture)),"Ouverture_fermeture"]

# Supprimer la colonne Ouverture_fermeture
campagnes <- select(campagnes, -Ouverture_fermeture, -no_mesure)

#######################
## Écriture du fichier CSV
#######################

# Ecriture des tables
write.csv(campagnes,file="./extdata/csv/campagnes.csv",row.names=F)


```
