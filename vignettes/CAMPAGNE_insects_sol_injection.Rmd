---
title: "Tutoriel pour injection des campagnes Insecgs Sol"
author: "Andrew MacDonald"
date: "novembre 2020"
output: html_document
---

## 1. Cr√©er une base de donn√©es excel

Afin d'injecter des nouvelles campagnes *insects sol* dans la base de donn√©es Col√©o, vous devez regrouper les informations suivantes dans un fichier excel :



|nom de variable |meaning |
|:-----------|:-------|
|nom_cellule                   |  Name of the cell      |
|no_de_reference_de_la_cellule |  code num√©rique unique pour chaque cellule      |
|no_de_reference_du_site       |  code alpha-num√©rique unique du site      |
|type_milieu                   |  'lac', 'rivi√®re', 'forestier', 'marais', 'marais c√¥tier', 'toundrique', 'tourbi√®re'      |
|type_identification           |  `TRI` ou `ID`      |
|no_echantillon                |  Sample number (MFFP syntax)      |
|date_debut                    |  date du d√©but du pr√©l√®vement      |
|date_fin                      |   date de la fin du pr√©l√®vement      |
|nom_scientifique              |  nom latin des esp√®ces observ√©es      |
|abondance                     |  Count of observation.      |


soil insect data is actually two different kinds of data. 

|nm                            |meaning |
|:-----------------------------|:-------|
|nom_cellule                   | Name of the cell         |
|no_de_reference_de_la_cellule | code num√©rique unique pour chaque cellule       |
|no_de_reference_du_site       | code alpha-num√©rique unique du site       |
|type_milieu                   |        |
|date_debut                    |  date du d√©but du pr√©l√®vement      |
|date_fin                      |  date de la fin du pr√©l√®vement     |
|technicien_1                  |  name of the technician involved       |
|technicien_2                  |        |
|code_piege                    |  MFFP code for the trap in question      |
|latitude                      |        |
|longitude                     |        |
|no_echantillon                |        |
|date_de_collecte              |        |

Note that soil insects are peculiar, in that unlike other datasets in coleo they produce two kinds of data. First, soil insects which are sorted to species -- and second, soil insects which are not identified to species. More on this below

Note : ne pas laisser de case vide, inscrire NA lorsque n√©cessaire
Note bis : Il est essentiel que ce tableau ne contiennent QUE des nouvelles campagnes ! Sous peine de voir √©chou√© le code qui suit.



## 2. Corriger la base de donn√©es

Il est tr√®s important de s'assurer que la base de donn√©es excel soit sans erreur **avant** de l'injecter dans Col√©o. Col√©o n'a pas de syst√®me de correction et va prendre toutes les entr√©es, m√™me si elles contiennent des erreurs.


## 3. Cr√©er un projet R

Dans RStudio,

* Aller dans `File` > `New Project` > `New Directory` > `New Project`
* Choisir un nom de projet et un lieu dans les fichiers pour le projet

Les projets permettent de travailler dans un r√©pertoire de travail (*working directory*). La base de donn√©es doit donc √™tre sauvegard√©e dans le m√™me dossier que le projet afin de faire parti du r√©pertoire de travail.

## 4. Sauvegarder la base de donn√©es en format .csv dans le m√™me dossier que le projet R

<div class = "blue">

**Rappel** - L'encodage du fichier .csv doit √™tre en "UTF-8"

</div>

## 5. Installer et charger les packages n√©cessaires

S'il ne s'agit pas de vos premi√®res injections dans Col√©o avec R, vous pouvez directement passer √† l'**√©tape 5.2**. Sinon vous devez installer les packages n√©cessaires. 

### 5.1. Installation des packages

Dans RStudio :

```r
install.packages("devtools")
install.packages("dplyr")
```

Pour installer le package `rcoleo`, il faut utiliser le package `devtools`, il faut donc l'appeller avec `library()`

```r
library(devtools)
# Installation du package rcoleo √† partir de github
install_github("TheoreticalEcosystemEcology/rcoleo") 
```

### 5.2. Chargement des packages

```r
install.packages("rcoleo")
install.packages("dplyr")
```

## 6. Mettre en cache son jeton d'acc√®s

Ce jeton permet d'apporter des modifications dans Col√©o. Il est unique et se retrouve dans Col√©o, sous le profil de l'utilisateur dans le menu √† gauche.

```r
saveRDS("votrejeton",".httr-oauth")
```

Cette √©tape n'est faite qu'une fois et permet l'enregistrement de votre jeton dans le r√©pertoire du projet R. Une fois faite, elle est supprim√©e du code d'injection. Le jeton est confidentiel.


## 7. V√©rification pr√©-injection

La succession d'√©tape qui suivent permettent de v√©rifier si les cellules, les sites, les noms d'esp√®ces et les attributs associ√©s aux campagnes √† injecter existent d√©j√† dans Col√©o.

### 7.1. Cr√©ation d'un objet R avec les nouvelles campagnes √† ins√©rer dans Col√©o

```r
camp <- read.csv("./lenomdevotrebasededonn√©es.csv",
                 header = TRUE,
                 sep = ',',
                 stringsAsFactors = FALSE,
                 encoding = "UTF-8") # l'encoding UTF-8 permet de garder les accents
```
### 7.2. Acquisition de la liste des cellules, des sites, des noms d'esp√®ce de r√©f√©rence et des attributs d√©j√† pr√©sentes dans Col√©o et cr√©ation d'un objet R pour chacune

```r
# Acquisition cellules Col√©o
cells <- rcoleo::get_cells()
cells <- do.call("rbind", cells[[1]]$body)

# Acquisition sites Col√©o
sites <- rcoleo::get_sites()
sites <- do.call("rbind", sites[[1]]$body)

# Acquisition nom esp√®ces Col√©o
species <- rcoleo::get_species()
species <- do.call("rbind", species[[1]]$body)

# Acquisition des attributs dans Col√©o
attrs <- rcoleo::get_gen("/attributes")
attrs <- do.call("rbind.fill", attrs$body)
```

### 7.3. V√©rification de l'existence des cellules, sites, noms d'esp√®ces et des attributs associ√©s aux nouvelles campagnes dans Col√©o

#### 7.3.1. Pour les cellules

```r
# Test pour v√©rifier l'existence des cellules dans Col√©o
cell_abs <- rcoleo::COLEO_comp(unique(camp$cell_code),
                               unique(cells$cell_code))
cell_abs
```

La sortie R vous indique si vous pouvez passer √† l'√©tape suivante ou non. Dans le cas o√π certaines cellules n'existent pas dans Col√©o, il sera n√©cessaire d'importer ces cellules avant de continuer l'insertions des nouvelles campagnes. Pour ce faire, vous utilisez l'objet `cell_abs` que vous venez de cr√©er et qui contient la liste des cellules √† cr√©er et suivre les √©tapes d√©taill√©es en d√©roulant la vignette **Injection des cellules** ci-dessous.

<script>
function myFunction1() {
    var x = document.getElementById("myDIV_cells");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
}
</script>
 
<div id="myDIV_cells">


##### **7.3.1.1.** Cette √©tape permet d'enregistrer un objet dans R avec les informations de toutes les cellules existantes.

```r
shp_cells <- rgdal::readOGR(dsn="./shp",
                            layer="Cellule_terrain_2016-2020") # Ici le fichier shapefile est plac√© dans un dossier shp et on appelle tous les fichiers nomm√©s "Cellule_terrain_2016_2020"
```

##### **7.3.1.2.** Cette √©tape permet d'extraire les informations n√©cessaires concernant les nouvelles cellules et de formater ces informations de sorte √† pouvoir les ins√©rer dans Col√©o.

```r
# Cr√©ation d'une liste vide pour l'objet final
shp_cells_list <- list()

for (i in 1:length(cell_abs)){

# Obtention des information pour un cellule
  shp <- shp_cells[shp_cells$IJ == cell_abs[i] ,]

# Cr√©ation d'une liste avec les informations n√©cessaires pour chaque cellule
  cells_ls <- list()
  cells_ls$cell_code <- cell_abs[i] # Code de la cellule
  cells_ls$name <- unique(shp_cells[shp_cells$IJ == cell_abs[i] & !is.na(shp_cells$Nom),]@data$Nom) # Nom de la cellule

  if(identical(cells_ls$name, character(0))){
  
    cells_ls$name <- NULL
    
  } # Information absente si pas de nom pour la cellule

# Cr√©ation de l'objet spatial pour les coordonn√©es de la cellule
  shp_sp <- as(shp, "SpatialPolygons")
  cells_ls$geom <- geojsonio::geojson_list(shp)$features[[1]]$geometry # Caract√©ristiques de l'objet spatial
  cells_ls$geom$crs <- list(type = "name",
                            properties = list(name = "EPSG:4326")) # Information sur le syst√™me de coordonn√©es de r√©f√©rence (CRS)

# Alimentation de l'objet final avec un niveau pour chaque cellule
  shp_cells_list[[i]] <- cells_ls
}
```

##### **7.3.1.3.** Nous pouvons maintenant ins√©rer les nouvelles cellules dans la base de donn√©es Col√©o.

```r
# Envoi de la liste de nouvelles cellules vers Col√©o
COLEO_cells <- post_cells(shp_cells_list)
```

La sortie R vous informe sur le d√©roulement de l'insertion. Le message `Good job ! Toutes les insertions ont √©t√© cr√©√©es dans COLEO` indique que les informations ont bien √©t√© enregistr√©es dans Col√©o. Dans le cas inverse, le message `Oups... un probl√®me est survenu` apparait, suivi des codes de statut pour chaque requ√™te d'injections (pour plus d'informations √† propos des [codes de statut](https://http.cat/)).

##### **7.3.1.4.** ATTENTION, finissez en faisant la mise √† jour de la liste des cellules pr√©sentes dans Col√©o.

```r
# Mise √† jour de la liste des cellules provenant de Col√©o
cells <- rcoleo::get_cells()
cells <- do.call("rbind", cells[[1]]$body)
```
 
</div>

<script>
document.getElementById("myDIV_cells").style.display ="none"
</script>

<button onclick="myFunction1()">Vignette Injection des cellules</button>

Vous pouvez maintenant r√©cup√©rer l'ID unique des cellules.

```r
camp <- dplyr::left_join(camp,
                         cells[, c("id", "cell_code")],
                         by = "cell_code")
names(camp)[names(camp) == "id"] <- "cell_id"
```

#### 7.3.2. Pour les sites

```r
# Test pour v√©rifier l'existence des sites dans Col√©o
site_abs <- rcoleo::COLEO_comp(unique(camp$site_code),
                               unique(sites$site_code))
site_abs
```

La sortie R vous indique si vous pouvez passer √† l'√©tape suivante ou non. Dans le cas o√π certains sites n'existent pas dans Col√©o, il sera n√©cessaire d'importer ces sites avant de continuer l'insertions des nouvelles campagnes. Pour ce faire, vous utilisez l'objet `site_abs` que vous venez de cr√©er et qui contient la liste des cellules √† cr√©er et suivre les √©tapes d√©taill√©es en d√©roulant la vignette **Injection des sites** ci-dessous.

<script>
function myFunction2() {
    var x = document.getElementById("myDIV_sites");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
}
</script>

<div id="myDIV_sites">


##### **7.3.2.1.** Cette √©tape permet de s√©lectionner les informations n√©cessaires pour les sites absents de Col√©o.

```r
# S√©lection des lignes du tableau concernant les sites manquants
site_df <- camp[camp$site_code %in% site_abs, c("cell_id", "site_code", "type_hab", "opened_at", "lat", "lon")]

# Retrait des lignes dupliqu√©es
site_df <- site_df[!duplicated(site_df),]

# Changement du nom de la variable "type_hab" pour correspondre √† celle de Col√©o ("type")
names(site_df)[names(site_df) == "type_hab"] <- "type"

# Cr√©ation de la variable geom √† partir des variables "lat" & "lon"
site_df_ls <- apply(site_df, 1, as.list) # Cr√©ation de la liste
str(site_df_ls) # V√©rification de la structure de l'objet

geom <- apply(site_df,1, function(x){

  if(!any(is.na(x["lat"]), is.na(x["lon"]))){
  
    return(geojsonio::geojson_list(as.numeric(c(x["lon"], x["lat"])))$features[[1]]$geometry)
    
  } else {
  
    return(NA)
    
  }})

for(i in 1:length(site_df_ls)){ # Fusionner les deux listes (geomations + sites)

  site_df_ls[[i]]$geom <- geom[i][[1]]
  if(is.list(site_df_ls[[i]]$geom)){
  
    site_df_ls[[i]]$geom$crs <- list(type = "name",
                                     properties = list(name="EPSG:4326"))
  }
}
```
##### **7.3.2.2.** Nous pouvons maintenant ins√©rer les nouveaux sites dans la base de donn√©es Col√©o.
```r
# Envoi de la liste des nouveaux sites vers Col√©o
COLEO_sites <- rcoleo::post_sites(site_df_ls)
```

La sortie R vous informe sur le d√©roulement de l'insertion. Le message `Good job ! Toutes les insertions ont √©t√© cr√©√©es dans COLEO` indique que les informations ont bien √©t√© enregistr√©es dans Col√©o. Dans le cas inverse, le message `Oups... un probl√®me est survenu` apparait, suivi des codes de statut pour chaque requ√™te d'injections (pour plus d'informations √† propos des [codes de statut](https://http.cat/)).

##### **7.3.2.3.** ATTENTION, finissez en faisant la mise √† jour de la liste des sites pr√©sents dans Col√©o.

```r
# Mise √† jour de la liste des sites provenant de Col√©o
sites <- rcoleo::get_sites()
sites <- do.call("rbind", sites[[1]]$body)
```
</div>

<script>
document.getElementById("myDIV_sites").style.display ="none"
</script> 

<button onclick="myFunction2()">Vignette Injection des sites</button>

Vous pouvez maintenant r√©cup√©rer l'ID unique des sites.

```r
camp <- dplyr::left_join(camp,
                         sites[, c("id", "site_code")],
                         by = "site_code")
names(camp)[names(camp) == "id"] <- "site_id"
```


#### 7.3.3. Pour les noms d'esp√®ces

```r
# Test pour v√©rifier l'existence des noms des esp√®ces dans Col√©o
sp_abs <- rcoleo::COLEO_comp(unique(camp$taxa_name),
                             unique(species$name))
sp_abs
```

La sortie R vous indique si vous pouvez passer √† l'√©tape suivante ou non. Dans le cas o√π certains noms d'esp√®ces n'existent pas dans Col√©o, il sera n√©cessaire d'importer ces noms avant de continuer l'insertions des nouvelles campagnes. Pour ce faire, vous utilisez l'objet `sp_abs` que vous venez de cr√©er et qui contient la liste des cellules √† cr√©er et suivre  les √©tapes d√©taill√©es dans la vignette **Injection des noms d'esp√®ce**.

<script>
function myFunction3() {
    var x = document.getElementById("myDIV_taxa");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
}
</script>

<div id="myDIV_taxa">

##### **7.3.3.1.** Cette √©tape permet de s√©lectionner les informations n√©cessaires pour les noms d'esp√®ce absents de Col√©o.

```r
# Formatage du tableau √† ins√©rer
taxa_df <- camp[camp$taxa_name %in% sp_abs,]
taxa_df <- select(taxa_df,
                    name = taxa_name,
                    vernacular_fr) # colonnes n√©cessaires
```
##### **7.3.3.2.** Cette √©tape permet de formatter les donn√©es afin de pouvoir les injecter dans la base de donn√©es Col√©o.

```r
# Retrait des lignes dupliqu√©es
taxa_df <- taxa_df[!duplicated(taxa_df),] 

# Formatage des donn√©es sous forme de liste
taxa_df_ls <- apply(taxa_df, 1, as.list)
```
##### **7.3.3.3.** On injecte dans la base de donn√©es Col√©o.
```r
# Injection
COLEO_taxa <- rcoleo::post_species(taxa_df_ls)
```

***ATTENTION*** R√©fl√©chir au fait que toutes les informations pour les esp√®ces ne sont pas renseign√©es avec cette m√©thode
</div>

<script>
document.getElementById("myDIV_taxa").style.display ="none"
</script> 

<button onclick="myFunction3()">Vignette injection noms d'esp√®ce</button>

#### 7.3.3. Pour les attributs

```r
# Contenu de la table des attributs dans Col√©o
attrs
```
V√©rifier si les attributs n√©cessaires √† vos campagnes sont bien pr√©sents dans cette table.


### 7.4 Optimisation du tableau √† injecter initial

```r
# Ajout du site_id
camp <- dplyr::left_join(camp, sites[, c("id", "site_code")], by = "site_code")
names(camp)[names(camp) == "id"] <- "site_id"
```




## 7. V√©rification pr√©-injection

La succession d'√©tape qui suivent permettent de v√©rifier si les cellules, les sites et les noms d'esp√®ces associ√©s aux campagnes √† injecter existent d√©j√† dans Col√©o.

### 7.1. Cr√©ation d'un objet R avec les nouvelles campagnes √† ins√©rer dans Col√©o






```r
library(googlesheets4)
library(tidyverse)

options(gargle_oauth_email = TRUE)
gs4_auth()
insecte_sol_obs <- range_read(sheet_address,
                              sheet = "insecte_sol_observation")

glimpse(insecte_sol_obs)
```

```
## Rows: 1,940
## Columns: 10
## $ nom_cellule                   [3m[38;5;246m<chr>[39m[23m "Bellechasse (A)", "Bellechasse (A)", "Bellechasse (A)", "Bellec‚Ä¶
## $ no_de_reference_de_la_cellule [3m[38;5;246m<chr>[39m[23m "141_108", "141_108", "141_108", "141_108", "141_108", "141_108"‚Ä¶
## $ no_de_reference_du_site       [3m[38;5;246m<chr>[39m[23m "141_108_F01", "141_108_F01", "141_108_F01", "141_108_F01", "141‚Ä¶
## $ type_milieu                   [3m[38;5;246m<chr>[39m[23m "Forestier", "Forestier", "Forestier", "Forestier", "Forestier",‚Ä¶
## $ type_identification           [3m[38;5;246m<chr>[39m[23m "ID", "ID", "ID", "ID", "ID", "ID", "ID", "ID", "ID", "ID", "TRI‚Ä¶
## $ no_echantillon                [3m[38;5;246m<chr>[39m[23m "2016-0020", "2016-0020", "2016-0021", "2016-0022", "2016-0024",‚Ä¶
## $ date_debut                    [3m[38;5;246m<list>[39m[23m [2016-05-26, 2016-05-26, 2016-05-26, 2016-05-26, 2016-05-26, 20‚Ä¶
## $ date_fin                      [3m[38;5;246m<dttm>[39m[23m 2016-06-20, 2016-06-20, 2016-06-20, 2016-07-20, 2016-07-20, 201‚Ä¶
## $ nom_scientifique              [3m[38;5;246m<chr>[39m[23m "Pterostichus pensylvanicus", "Notiophilus aeneus", "Melandryida‚Ä¶
## $ abondance                     [3m[38;5;246m<dbl>[39m[23m 1, 1, 1, 2, 1, 1, 3, 37, 1, 1, 42, 12, 4, 22, 31, 5, 16, 3, 1, 1‚Ä¶
```

```r
insecte_sol_piege <-  range_read(sheet_address,
                              sheet = "insecte_sol_info_piege",
                              na = "NA",
                              col_types = "ccccDDcccnncD")

insecte_sol_piege
```

```
## # A tibble: 517 x 13
##    nom_cellule no_de_reference‚Ä¶ no_de_reference‚Ä¶ type_milieu date_debut date_fin   technicien_1
##    <chr>       <chr>            <chr>            <chr>       <date>     <date>     <chr>       
##  1 M√©kinac (B) 135_104          135_104_F01      forestier   2016-05-20 2016-07-12 Caroline Du‚Ä¶
##  2 M√©kinac (B) 135_104          135_104_F01      forestier   2016-05-20 2016-07-12 Caroline Du‚Ä¶
##  3 M√©kinac (B) 135_104          135_104_F01      forestier   2016-05-20 2016-07-12 Caroline Du‚Ä¶
##  4 M√©kinac (B) 135_104          135_104_F01      forestier   2016-05-20 2016-07-12 Caroline Du‚Ä¶
##  5 M√©kinac (B) 135_104          135_104_F01      forestier   2016-05-20 2016-07-12 Caroline Du‚Ä¶
##  6 M√©kinac (B) 135_104          135_104_F01      forestier   2016-05-20 2016-07-12 Caroline Du‚Ä¶
##  7 Lac Simonc‚Ä¶ 132_116          132_116_F01      forestier   2016-06-03 2016-07-25 Caroline Du‚Ä¶
##  8 Lac Simonc‚Ä¶ 132_116          132_116_F01      forestier   2016-06-03 2016-07-25 Caroline Du‚Ä¶
##  9 Lac Simonc‚Ä¶ 132_116          132_116_F01      forestier   2016-06-03 2016-07-25 Caroline Du‚Ä¶
## 10 Bellechass‚Ä¶ 141_108          141_108_F01      forestier   2016-05-26 2016-07-20 Caroline Du‚Ä¶
## # ‚Ä¶ with 507 more rows, and 6 more variables: technicien_2 <chr>, code_piege <chr>, latitude <dbl>,
## #   longitude <dbl>, no_echantillon <chr>, date_de_collecte <date>
```

```r
glimpse(insecte_sol_piege)
```

```
## Rows: 517
## Columns: 13
## $ nom_cellule                   <chr> "M√©kinac (B)", "M√©kinac (B)", "M√©kinac (B)", "M√©kinac (B)", "M√©k‚Ä¶
## $ no_de_reference_de_la_cellule <chr> "135_104", "135_104", "135_104", "135_104", "135_104", "135_104"‚Ä¶
## $ no_de_reference_du_site       <chr> "135_104_F01", "135_104_F01", "135_104_F01", "135_104_F01", "135‚Ä¶
## $ type_milieu                   <chr> "forestier", "forestier", "forestier", "forestier", "forestier",‚Ä¶
## $ date_debut                    <date> 2016-05-20, 2016-05-20, 2016-05-20, 2016-05-20, 2016-05-20, 201‚Ä¶
## $ date_fin                      <date> 2016-07-12, 2016-07-12, 2016-07-12, 2016-07-12, 2016-07-12, 201‚Ä¶
## $ technicien_1                  <chr> "Caroline Dube", "Caroline Dube", "Caroline Dube", "Caroline Dub‚Ä¶
## $ technicien_2                  <chr> NA, NA, NA, NA, NA, NA, "Pierre-Alexis Drolet", "Pierre-Alexis D‚Ä¶
## $ code_piege                    <chr> "MP-05", "MP-06", "MP-07", "MP-05", "MP-06", "MP-07", "MP-12", "‚Ä¶
## $ latitude                      <dbl> 46.79415, 46.79401, 46.79410, 46.79415, 46.79401, 46.79410, 48.2‚Ä¶
## $ longitude                     <dbl> -72.30296, -72.30310, -72.30336, -72.30296, -72.30310, -72.30336‚Ä¶
## $ no_echantillon                <chr> "2016-0007", "2016-0008", "2016-0009", "2016-0011", "2016-0012",‚Ä¶
## $ date_de_collecte              <date> 2016-06-10, 2016-06-10, 2016-06-10, 2016-07-12, 2016-07-12, 201‚Ä¶
```

Note that in this example I am reading from google drive. If your spreadsheet is in a text format, remember to use `encoding = "UTF-8"`.

You can facilitate your work below by controlling the type of columns when you read them in.
Here I use the argument `col_types` to accomplish this. see `?readr::read_csv`


Here we can see that the columns of the dataset match what is above. 


## 8. Injections des nouvelles campagnes *insectes_sol*

Pour une injection compl√®te d'une campagne, il est n√©cessaire de passer par l'importation d'informations successives dans diff√©rentes tables de Col√©o. La hi√©rarchie des tables √† renseigner est cruciale, sans quoi l'injection de la campagne est vou√©e √† l'√©chec. Les prochaines √©tapes d√©taillent l'ajout d'information dans les tables:

1. Campagnes ("*/campaigns*")
2. Rep√®res ("*/landmarks*")
3. Observations ("*/observations*")
4. Observations des esp√®ces ("*/obs_species*")

### 8.1. Injections des informations sur les nouvelles campagnes

Les champs qui peuvent √™tre remplis dans la table **campagnes** ("/campaigns") de Col√©o sont les suivants (les champs en gras sont obligatoires) :

* **site_id** : √† r√©cup√©rer dans Col√©o
* **type** : nom de la campagne, ici "zooplanctons"
* **technicians** : liste compos√©e de "technicien_1" et "technicien_2"
* **opened_at** : corresppond √† "date_debut"
* **closed_at** : correspond √† "date_fin"
* *notes*

#### 8.1.1. On commence par s√©l√©ctionner les champs d'inter√™ts & on matche les noms de variables avec celles de Col√©o.


```r
inj_camp_insects <- dplyr::select(insecte_sol_piege, 
                               site_code = no_de_reference_du_site, 
                               opened_at = date_debut, 
                               closed_at = date_fin, 
                               technicien_1, 
                               technicien_2)
```

#### 8.1.2. On garde une ligne unique par nouvelle campagne.

```r
inj_camp_insects
```

#### 8.1.3. On r√©cup√®re le `site_id`, n√©cessaire √† l'injection.

```r
inj_camp_zoop <- dplyr::left_join(inj_camp_zoop, sites[, c(1,4)], by = "site_code")
names(inj_camp_zoop)[6] <- "site_id"
```

#### 8.1.4. On cr√©√© une liste pour le nom des technicien/ne/s.

```r
tech <- list() # Cr√©ation d'un objet `list` vide

for(i in 1:length(inj_camp_zoop$site_code)){
  tech[[i]] <- list(inj_camp_zoop$technicien_1[[i]], inj_camp_zoop$technicien_2[[i]])
} # Chaque niveau de la liste correspond √† une association des deux noms des technicien/ne/s pour chaque ligne du tableau

inj_camp_zoop$technicians <- tech # Ajout de la liste au tableau √† injecter dans Col√©o
```

#### 8.1.5. On renseigne le type de campagnes, ici **zooplancton**. Prenez garde √† bien conserver la m√™me orthographe.

```r
inj_camp_zoop$type <- "zooplancton"
```

#### 8.1.6. On tansforme le tableau en liste afin de pouvoir l'injecter dans Col√©o.

```r
camp_ls <- apply(inj_camp_zoop,1,as.list)
str(camp_ls)
```
#### 8.1.7. Il est maintenant possible de proc√©der √† l'injection.

```r
COLEO_camp_inj <- post_campaigns(camp_ls)
```
La sortie R vous informe sur le d√©roulement de l'insertion. Le message `Good job ! Toutes les insertions ont √©t√© cr√©√©es dans COLEO` indique que les informations ont bien √©t√© enregistr√©es dans Col√©o. Dans le cas inverse, le message `Oups... un probl√®me est survenu` apparait, suivi des codes de statut pour chaque requ√™te d'injections (pour plus d'informations √† propos des [codes de statut](https://http.cat/)).

### 8.2. Injections des rep√®res associ√©s aux nouvelles campagnes

Les champs qui peuvent √™tre remplis dans Col√©o sont les suivants (les champs en gras sont obligatoires) :

* **campaign_id** : doit matcher avec site_code/site_id & opened_at
* **geom**

#### 8.2.1. On commence par s√©l√©ctionner les champs d'inter√™ts & on matche les noms de variables avec celles de Col√©o.

```r
inj_land_zoop <- dplyr::select(camp_zoopl, site_code=no_de_reference_du_site, opened_at=date_debut, lat=latitude, lon = longitude)
```

#### 8.2.2. On r√©cup√®re le `site_id`, n√©cessaire √† l'injection.

```r
inj_land_zoop <- dplyr::left_join(inj_land_zoop, sites[, c(1, 4)], by = "site_code")
names(inj_land_zoop)[5] <- "site_id"
```

#### 8.2.3. On r√©cup√®re le `campaign_id`, n√©cessaire √† l'injection.

```r
inj_land_zoop$opened_at <- as.character(inj_land_zoop$opened_at)
inj_land_zoop <- dplyr::left_join(inj_land_zoop, camp[, c(1, 2, 5)], by = c("site_id", "opened_at"))
names(inj_land_zoop)[6] <- "campaign_id"
```

#### 8.2.4. On garde une ligne par rep√®re (c'est-√†-dire par campagne).

```r
inj_land_zoop <- inj_land_zoop[!duplicated(inj_land_zoop),]
```

#### 8.2.5. On transforme le tableau en liste pour pouvoir l'injecter dans Col√©o.

```r
land_ls <- apply(inj_land_zoop,1,as.list)
str(land_ls)
```

#### 8.2.6. On cr√©√© le champs `geom` de COLEO, sous forme de liste, en utilisant les variables *lat* & *lon* du tableau.

```r
geom <- apply(inj_land_zoop,1, function(x){
if(!any(is.na(x["lat"]),is.na(x["lon"]))){
  return(geojsonio::geojson_list(as.numeric(c(x["lon"],x["lat"])))$features[[1]]$geometry)
} else {
  return(NA)
}})
```

#### 8.2.7. On fusionne les deux listes en pr√©vision de l'injection dans Col√©o.

```r
for(i in 1:length(land_ls)){
 land_ls[[i]]$geom <- geom[i][[1]]
 if(is.list(land_ls[[i]]$geom)){
   land_ls[[i]]$geom$crs <- list(type="name",properties=list(name="EPSG:4326"))
 }
}
```
La sortie R vous informe sur le d√©roulement de l'insertion. Le message `Good job ! Toutes les insertions ont √©t√© cr√©√©es dans COLEO` indique que les informations ont bien √©t√© enregistr√©es dans Col√©o. Dans le cas inverse, le message `Oups... un probl√®me est survenu` apparait, suivi des codes de statut pour chaque requ√™te d'injections (pour plus d'informations √† propos des [codes de statut](https://http.cat/)).

#### 8.2.7. Il est maintenant possible de proc√©der √† l'injection.

```r
COLEO_land_inj <- post_landmarks(land_ls)
```

### 8.3. Injections des observations associ√©es aux nouvelles campagnes

Les champs qui peuvent √™tre remplis dans Col√©o sont les suivants (les champs en gras sont obligatoires) :

* **date_obs** : date_debut
* **is_valid** : par d√©faut = 1
* **campaign_id** : r√©cup√©ration avec site_id et opened_at(=date_obs)
* *campaign_info*
* *time_obs*
* *stratum*
* *axis*
* *distance*
* *distance_unit*
* *depth* : Profondeur_m
* *sample_id*
* *thermograph_id*
* *notes* : Date_denombrement + Taxonomiste


#### 8.3.1. On s√©l√©ctionne les champs d'inter√™ts & on matche les noms de variables avec celles de Col√©o.

```r
inj_obs_zoop <- dplyr::select(camp_zoopl, site_code=no_de_reference_du_site, opened_at=date_debut, depth = Profondeur_m)
inj_obs_zoop$is_valid <- 1
inj_obs_zoop$notes <- paste0(camp_zoopl$Taxonomiste, "Date_denombrement", camp_zoopl$Date_denombrement, sep = "-")
```

#### 8.3.2. On r√©cup√®re le `site_id`, n√©ceesaire √† l'injection.

```r
inj_obs_zoop <- dplyr::left_join(inj_obs_zoop, sites[, c(1, 4)], by = "site_code")
names(inj_obs_zoop)[6] <- "site_id"
```

#### 8.3.3. On r√©cup√®re le `campaign_id`, n√©cessaire √† l'injection.

```r
inj_obs_zoop$opened_at <- as.character(inj_obs_zoop$opened_at)
inj_obs_zoop <- dplyr::left_join(inj_obs_zoop, camp[, c(1, 2, 5)], by = c("site_id", "opened_at"))
names(inj_obs_zoop)[7] <- "campaign_id"
```

#### 8.3.4. On modifie le nom pour la date d'observation.

```r
names(inj_obs_zoop)[2] <- "date_obs"
```

#### 8.3.5. On conserve les lignes uniques du jeu de donn√©es.

```r
inj_obs_zoop <- inj_obs_zoop[!duplicated(inj_obs_zoop),]
```

#### 8.3.6. On transforme le tableau en liste pour l'injection dans Col√©o.

```r
obs_ls <- apply(inj_obs_zoop,1,as.list)
```

#### 8.3.7. Il est maintenant possible de proc√©der √† l'injection.

```r
COLEO_obs_inj <- post_observations(obs_ls)
```
La sortie R vous informe sur le d√©roulement de l'insertion. Le message `Good job ! Toutes les insertions ont √©t√© cr√©√©es dans COLEO` indique que les informations ont bien √©t√© enregistr√©es dans Col√©o. Dans le cas inverse, le message `Oups... un probl√®me est survenu` apparait, suivi des codes de statut pour chaque requ√™te d'injections (pour plus d'informations √† propos des [codes de statut](https://http.cat/)).

### 8.4. Injections de l'abondance des esp√®ces associ√©es aux nouvelles campagnes

Les champs qui peuvent √™tre remplis dans Col√©o sont les suivants (les champs en gras sont obligatoires) :

* **taxa_name** : nom_scientifique
* **variable** : "abondance"
* **observation_id** : √† r√©cup√©rer avec site_id --> site_code --> campaign_id + opened_at
* *value* : abondance

#### 8.4.1. On s√©l√©ctionne les champs d'inter√™ts & on matche les noms de variables avec celles de Col√©o.

```r
inj_data_zoop <- dplyr::select(camp_zoopl, site_code=no_de_reference_du_site, opened_at=date_debut, taxa_name = nom_scientifique, value = abondance)
inj_data_zoop$variable <- "abondance"
```

#### 8.4.2. On r√©cup√®re le `site_id`, n√©cessaire √† l'injection.

```r
inj_data_zoop <- dplyr::left_join(inj_data_zoop, sites[, c(1, 4)], by = "site_code")
names(inj_data_zoop)[6] <- "site_id"
```

#### 8.4.3. On r√©cup√®re le `campaign_id`, n√©cessaire √† l'injection.

```r
inj_data_zoop$opened_at <- as.character(inj_data_zoop$opened_at)
inj_data_zoop <- dplyr::left_join(inj_data_zoop, camp[, c(1, 2, 5)], by = c("site_id", "opened_at"))
names(inj_data_zoop)[7] <- "campaign_id"
```

#### 8.4.4. On r√©cup√®re le `observation_id`, n√©cessaire √† l'injection.

```r
names(inj_data_zoop)[2] <- "date_obs"
inj_data_zoop <- dplyr::left_join(inj_data_zoop, obs[, c(1, 2, 12)], by = c("campaign_id", "date_obs"))
names(inj_data_zoop)[8] <- "observation_id"
```

#### 8.4.5. On transforme le jeu de donn√©es en liste pour l'injection dans Col√©o.

```r
data_ls <- apply(inj_data_zoop,1,as.list)
```

#### 8.4.6. Il est maintenant possible de proc√©der √† l'injection.

```r
COLEO_data_inj <- postpost_obs_species(data_ls) # Fonctionnel

```
La sortie R vous informe sur le d√©roulement de l'insertion. Le message `Good job ! Toutes les insertions ont √©t√© cr√©√©es dans COLEO` indique que les informations ont bien √©t√© enregistr√©es dans Col√©o. Bravo ! Vous venez de terminer les √©tapes d'injections des campagnes **zooplancton** ! Dans le cas inverse, le message `Oups... un probl√®me est survenu` apparait, suivi des codes de statut pour chaque requ√™te d'injections (pour plus d'informations √† propos des [codes de statut](https://http.cat/)).
