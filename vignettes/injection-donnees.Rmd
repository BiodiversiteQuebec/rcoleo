---
title: "Injection des données vers coleo"
author: "Victor Cameron", "Andrew MacDonald"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---


```{r, include=FALSE}
library(httptest2)
start_vignette("coleo_data_injection")
knitr::opts_chunk$set(error = TRUE, out.width = 80)
```

This vignette shows the process of injecting one complete dataset into the COLEO database.
The example shown here follows the injection procedure for Insectes du Sol, but the process should be the same for any campaign type.


All datasets require both the *cell* and the *site* to be uploaded first.
For completeness, this vignette starts with showing this process before moving to more specific parts of the injection.


<!-- TODO allow Cells and Sites to collapse in this vignette because we should not need them MOST of the time -->


## 1. Cells

We start with an example of data from an imaginary cell:

```{r dput_cell, include=FALSE}
cell_data <- structure(list(cell_code = "111_777", name = "Middle Earth", 
    geom = structure(list(structure(list(structure(c(-68.784529, 
    -68.92058, -69.051611, -68.915541, -68.784529, 48.112211, 
    48.02487, 48.11558, 48.203192, 48.112211), .Dim = c(5L, 2L
    ))), class = c("XY", "POLYGON", "sfg"))), class = c("sfc_POLYGON", 
    "sfc"), precision = 0, bbox = structure(c(xmin = -69.051611, 
    ymin = 48.02487, xmax = -68.784529, ymax = 48.203192), class = "bbox"), crs = structure(list(
        input = "NAD83", wkt = "GEOGCRS[\"NAD83\",\n    DATUM[\"North American Datum 1983\",\n        ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4269]]"), class = "crs"), n_empty = 0L)), row.names = c(NA, 
-1L), groups = structure(list(.rows = structure(list(1L), ptype = integer(0), class = c("vctrs_list_of", 
"vctrs_vctr", "list"))), row.names = c(NA, -1L), class = c("tbl_df", 
"tbl", "data.frame")), class = c("rowwise_df", "tbl_df", "tbl", 
"data.frame"))
```

```{r, message = FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(rcoleo)
```



```{r}
cell_data
```

Note that the column `geom` is a `POLYGON` type of object. We need to work with the literal spatial polygons that describe the shape of the cells. To get these, we need to read in the shapefiles directly, for example using `sf::read_sf("CelluleTerrain2016_2021_juin2021/CellulesTerrain2016_2021_juin2021.shp")`

### 1.1. reformatting Cell data

Once we have this information, we need to reformat it to prepare for injection. We can use a function from `rcoleo` to facilitate this step

```{r cell_fmt_geom, message=FALSE}
cell_data_reformat <- cell_data |> 
  rowwise() |> 
  mutate(geom = list(rcoleo::coleo_cell_geom_fmt(geom)))

str(cell_data_reformat)
```

This step transforms the `geom` column from a spatial object into a nested list. This is what we will inject into the COLEO database.

Another important point is the use of `rowwise()` in the code above. This is a convenient way to work with dataframes going one row at a time. Here, each row contains one cell for injection. You can read more about it [here](https://dplyr.tidyverse.org/articles/rowwise.html). 

### 1.2. Create the API request

Before we inject our data, we will make our requests and inspect them to make sure they work.

```{r}
cell_data_req <- cell_data_reformat |> 
  dplyr::mutate(inject_request = list(
    coleo_inject_general_df(dplyr::cur_data_all(), endpoint = "cells")
  ))
```

This step makes our request. Important things to note:

* we need to specify the endpoint where we will inject the data. Here it is `"cells"`
* we use `dplyr::cur_data_all()` to access every column of the current row of the dataset
* we use all the data in the current row. NOTE that if there is a column called "data", then `coleo_inject_general_df()` will drop it. 
* This is the step where you need to have your access key saved for Rcoleo. see the rcoleo site to set that up!
* we use `list()` to wrap the result of `coleo_inject_general_df()` because we want to store the prepared column in our dataframe, inside a list.

Let's look at this request column:

```{r, results='hold'}
print(cell_data_req$inject_request[[1]])
```

We can access the actual body of the request with:

```{r}
httr2::req_dry_run(cell_data_req$inject_request[[1]])
```

This is our last chance to make SURE we are injecting the right thing. The code at the bottom is JSON and is what will be injected into the database.

### 1.3. Injecting a cell

When we are sure that we've got the right data, we can proceed to injection:

```{r}
cell_data_inject_result <- coleo_injection_execute(cell_data_req)

cell_data_inject_result
cell_data_inject_result$result
```

the function `coleo_injection_execute` has done two things:

* performed the request using `httr2::req_perform`. This actually injects the data
* wrapped the result in a `list()` and saved the results in a new data.frame

This second step is important -- it lets us preserve the response from the server. This response contains useful information. For example, we can extract the ID of the cell we just injected:

```{r}
cell_data_inject_result |> 
  mutate(id = coleo_extract_id(result))
```

This is possible because when we inject data, the API sends back a response that contains the new ID that was made for the new observation.

**NOTE** the above step could also be completed manually:

```{r, eval=FALSE}
cell_data_req |> 
  dplyr::mutate(inject_result = list(httr2::req_perform(inject_request)))
```


## 2. Sites

We begin with a demonstration site:

```{r}
imaginary_sites <- tibble::tribble(
  ~cell_code,    ~site_code,    ~site_name,  ~site_type, ~site_lat,  ~site_lon, ~site_date_opened,
   "111_777",   "111_777_N09", "Mordor",     "tourbière", 48.133559,     -68.42,      "2020-01-01",
   "111_777",   "111_777_E03", "Lorien",     "forestier", 41.133559,     -67.33,      "2020-01-01"
  ) |> 
  rowwise()

```

We begin by preparing the dataset for injection. 

First, we format the data for injection and prepare the injection request:

```{r}
imaginary_sites_for_injection <- imaginary_sites |>
  coleo_injection_prep(db_table = "sites")

imaginary_sites_for_injection

# visually inspect the injection
httr2::req_dry_run(imaginary_requests$inject_request[[1]])
```

the function `coleo_injection_prep` has automaticaly obtained cell ID and removed the cell_code, renamed the columns, reformatted the spatial information, and nested any unnecessary columns as "data".

Now we inject them:

```{r}
# run and save all the injections
imaginary_injected <- coleo_injection_execute(imaginary_requests)

imaginary_injected
```

These two sites were injected successfully!

## 3. Injections de données (campagnes) vers la base de données coleo

This vignette will show how to inject fake soil insect data, which will allow us to show the injection process:


We start with some fake campaign information that we save into a coleo template. La particularité des templates coleo est que les données sont sauvées dans un feuille du document excel nommé "6. Template de téléversement".

```{r}
# Fake data
imaginary_insects <- tibble::tribble(
     ~sites_site_code, ~campaigns_type, ~campaigns_opened_at, ~campaigns_closed_at, ~observations_date_obs, ~observations_is_valid, ~traps_trap_code, ~landmarks_lat, ~landmarks_lon, ~samples_sample_code, ~campaigns_technicians, ~ref_species_rank, ~ref_species_tsn, ~ref_species_name, ~obs_species_taxa_name, ~obs_species_variable, ~obs_species_value,   ~observations_notes,
  "111_777_E03", "insectes_sol",          "2020-06-08",          "2020-06-30",      "2020-06-30",                  TRUE,     "A-N1",  50.56699, -74.44866,  "2020-0097",       "Legolas, Gimli",  "sous-classe",      9999,       "Fake_beetleA",         "Fake_beetleA",           "abondance",                  1,        "fascinating",
  "111_777_E03", "insectes_sol",          "2020-06-08",          "2020-06-30",      "2020-06-30",                  TRUE,     "A-N1",  50.56699, -74.44866,  "2020-0097",       "Legolas, Gimli",       "espèce",      9998,       "Fake_beetleB",         "Fake_beetleB",           "abondance",                  6,                   NA,
  "111_777_E03", "insectes_sol",          "2020-06-08",          "2020-06-30",      "2020-06-30",                  TRUE,     "A-N1",  50.56699, -74.44866,  "2020-0097",       "Legolas, Gimli",       "espèce",      9997,       "Fake_beetleC",         "Fake_beetleC",           "abondance",                 10,          "incomplet",
  "111_777_E03", "insectes_sol",          "2020-06-08",          "2020-06-30",      "2020-06-30",                  TRUE,    "B-NE1",  50.56698,  -74.4487,  "2020-0098",       "Legolas, Gimli",       "classe",      9999,       "Fake_beetleA",         "Fake_beetleA",           "abondance",                  1,                   NA,
  "111_777_E03", "insectes_sol",          "2020-06-30",          "2020-07-21",      "2020-07-21",                  TRUE,    "B-NE1",  50.56698,  -74.4487,  "2020-0105",       "Legolas, Gimli",  "sous-classe",      9998,       "Fake_beetleB",         "Fake_beetleB",           "abondance",                  3, "not sure about one",
  "111_777_E03", "insectes_sol",          "2020-06-08",          "2020-06-30",      "2020-06-30",                  TRUE,    "B-NE1",  50.56698,  -74.4487,  "2020-0098",       "Legolas, Gimli",       "classe",    117273,       "Danaus plexippus",     "Danaus plexippus",       "abondance",                  1,                   NA
  )

knitr::kable(imaginary_insects)

# Save the data into a fake coleo template
fileName <- paste0(tempdir(), "coleo_imaginary_insects_template.xlsx")
    xlsx::write.xlsx(
        as.data.frame(imaginary_insects),
        fileName,
        sheetName = "6. Template de téléversement")
```


Important things to notice about the data are:

* the only site-level information is the `sites_site_code`
* all the columns have prefixes (e.g. "*campaigns_*type" or "*landmarks_*lat). This is to differentiate columns which might have the same name but which are destined for different database tables. These will be automatically renamed during data preparation
* the format of dates is correct: AAAA-MM-JJ
* all columns have the correct values.

### 3.1. Lecture du jeu de données

On utilise la commande `coleo_read` pour lire les données du template excel. On peut aussi utiliser la commande `coleo_read_data` pour lire les données d'un fichier csv.

La commande `coleo_read_data` formate les données du template en un dataframe qui peut être injecté dans la base de données.


```{r}
data <- coleo_read(fileName)

knitr::kable(data)
```


### 3.2. Validation du jeu de données

On utilise la commande `coleo_validate` pour valider les données. Cette commande vérifie que les données sont dans le bon format et qu'elles sont complètes. Elle retourne un message d'erreur si les données ne sont pas valides.

Cette étape représente la majorité du travail d'injection des données.

```{r}
data_validated <- coleo_validate(data)
```


### 3.3. Injection des données (téléversement)

On utilise la commande `coleo_inject` pour injecter les données dans la base de données. Cette commande retourne un message d'erreur si les données ne sont pas valides.

Des messages sont produits pour indiquer les données qui ont été injectées avec succès et celles qui ont échouées. Les données qui ont échouées peuvent être retrouvées dans l'objet `data_injected` puisqu'elles ont une valeur `NULL` dans la colonne `*_id` qui leur est associée.

On peut consulter les message d'erreur puisqu'ils sont sauvés dans la colonne `*_error` de l'objet `data_injected`.

En cas d'erreur, se référer à la personne ressource.

```{r}
data_injected <- coelo_inject(data_validated)

knitr::kable(data_injected)
```


C'EST TOUT ! 

On peut maintenant consulter les données dans la base de données coleo.

## NOTE to vignette developers

This vignette uses some pre-recorded API responses to demonstrate the workflow. These are all stored in a directory in the `vignettes/` folder. see `vignette("vignettes", "httptest2")`.

HOWEVER you may get unexpected errors. This is caused by character encoding of French accents: the JSON saved may have a "?" character in place of an accented letter. Remember to check! 

```{r, include=FALSE}
end_vignette()
```

