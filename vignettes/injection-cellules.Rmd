---
# title: "Injection de nouvelles cellules dans Coléo"
# author: ""
# date: "16 septembre 2022"
output: html_document
---

## 1. Préparation des données
Les informations concernant les cellules sont regroupées dans un fichier de type shapefile. Les informations essentielles à l'insertion de nouvelles cellules dans Coléo sont les suivantes :
  
* **name** : nom de la cellule
* **cell_code** : obligatoire - code numérique unique pour chaque cellule
* **geom** : obligatoire - coordonnées de la cellule 

## 2. Créer un projet R
Dans RStudio,

* Aller dans File > New Project > New Directory > New Project
* Choisir un nom de projet et un lieu dans les fichiers pour le projet

Les projets permettent de travailler dans un répertoire de travail. Le fichiers shapefile (et autres fichiers associés) doit donc être sauvegardée dans le même dossier que le projet afin de faire parti du répertoire de travail.

## 3. Installer les packages nécessaires
Dans RStudio,


```r
install.packages("devtools")
install.packages("dplyr")
install.packages("rgdal")
install.packages("sp")
```
pour installer le package rcoleo, il faut utiliser le packages devtools, il faut donc l'appeller avec library()


```r
library(devtools)
# Installation du package rcoleo à partir de github
install_github("ReseauBiodiversiteQuebec/rcoleo") 
```
## 4. Mettre en cache son jeton d'accès
Ce jeton permet d'apporter des modifications dans Coléo. Il est unique et se retrouve dans Coléo, sous le profil de l'utilisateur dans le menu à gauche.

```r
saveRDS("votrejeton", ".httr-oauth")
```
Cette étape n'est faite qu'une fois et permet l'enregistrement de votre jeton dans le répertoire du projet R. Une fois faite, elle est supprimée du code d'injection. Le jeton est confidentiel.

## 5. Injection des cellules dans Coléo


This vignette shows the process of injecting one complete dataset into the COLEO database.
The example shown here follows the injection procedure for Insectes du Sol, but the process should be the same for any campaign type.


All datasets require both the *cell* and the *site* to be uploaded first.
For completeness, this vignette starts with showing this process before moving to more specific parts of the injection.



We start with an example of data from an imaginary cell:

```{r dput_cell, include=FALSE}
cell_data <- structure(list(cell_code = "111_777", name = "Middle Earth", 
    geom = structure(list(structure(list(structure(c(-68.784529, 
    -68.92058, -69.051611, -68.915541, -68.784529, 48.112211, 
    48.02487, 48.11558, 48.203192, 48.112211), .Dim = c(5L, 2L
    ))), class = c("XY", "POLYGON", "sfg"))), class = c("sfc_POLYGON", 
    "sfc"), precision = 0, bbox = structure(c(xmin = -69.051611, 
    ymin = 48.02487, xmax = -68.784529, ymax = 48.203192), class = "bbox"), crs = structure(list(
        input = "NAD83", wkt = "GEOGCRS[\"NAD83\",\n    DATUM[\"North American Datum 1983\",\n        ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4269]]"), class = "crs"), n_empty = 0L)), row.names = c(NA, 
-1L), groups = structure(list(.rows = structure(list(1L), ptype = integer(0), class = c("vctrs_list_of", 
"vctrs_vctr", "list"))), row.names = c(NA, -1L), class = c("tbl_df", 
"tbl", "data.frame")), class = c("rowwise_df", "tbl_df", "tbl", 
"data.frame"))
```

```{r, message = FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(rcoleo)
```



```{r}
cell_data
```

Note that the column `geom` is a `POLYGON` type of object. We need to work with the literal spatial polygons that describe the shape of the cells. To get these, we need to read in the shapefiles directly, for example using `sf::read_sf("CelluleTerrain2016_2021_juin2021/CellulesTerrain2016_2021_juin2021.shp")`

### 5.1 reformatting Cell data

Once we have this information, we need to reformat it to prepare for injection. We can use a function from `rcoleo` to facilitate this step

```{r cell_fmt_geom, message=FALSE}
cell_data_reformat <- cell_data |> 
  rowwise() |> 
  mutate(geom = list(rcoleo::coleo_cell_geom_fmt(geom)))

str(cell_data_reformat)
```

This step transforms the `geom` column from a spatial object into a nested list. This is what we will inject into the COLEO database.

Another important point is the use of `rowwise()` in the code above. This is a convenient way to work with dataframes going one row at a time. Here, each row contains one cell for injection. You can read more about it [here](https://dplyr.tidyverse.org/articles/rowwise.html). 

### 5.1 Create the API request

Before we inject our data, we will make our requests and inspect them to make sure they work.

```{r}
cell_data_req <- cell_data_reformat |> 
  dplyr::mutate(inject_request = list(
    coleo_inject_general_df(dplyr::cur_data_all(), endpoint = "cells")
  ))
```

This step makes our request. Important things to note:

* we need to specify the endpoint where we will inject the data. Here it is `"cells"`
* we use `dplyr::cur_data_all()` to access every column of the current row of the dataset
* we use all the data in the current row. NOTE that if there is a column called "data", then `coleo_inject_general_df()` will drop it. 
* This is the step where you need to have your access key saved for Rcoleo. see the rcoleo site to set that up!
* we use `list()` to wrap the result of `coleo_inject_general_df()` because we want to store the prepared column in our dataframe, inside a list.

Let's look at this request column:

```{r, results='hold'}
print(cell_data_req$inject_request[[1]])
```

We can access the actual body of the request with:

```{r}
httr2::req_dry_run(cell_data_req$inject_request[[1]])
```

This is our last chance to make SURE we are injecting the right thing. The code at the bottom is JSON and is what will be injected into the database.

### 5.3 Injecting a cell

When we are sure that we've got the right data, we can proceed to injection:

```{r}
cell_data_inject_result <- coleo_injection_execute(cell_data_req)

cell_data_inject_result
cell_data_inject_result$result
```

the function `coleo_injection_execute` has done two things:

* performed the request using `httr2::req_perform`. This actually injects the data
* wrapped the result in a `list()` and saved the results in a new data.frame

This second step is important -- it lets us preserve the response from the server. This response contains useful information. For example, we can extract the ID of the cell we just injected:

```{r}
cell_data_inject_result |> 
  mutate(id = coleo_extract_id(result))
```

This is possible because when we inject data, the API sends back a response that contains the new ID that was made for the new observation.

**NOTE** the above step could also be completed manually:

```{r, eval=FALSE}
cell_data_req |> 
  dplyr::mutate(inject_result = list(httr2::req_perform(inject_request)))
```

